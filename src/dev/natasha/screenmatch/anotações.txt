posso usar o 'var' para criar o objeto e não precisar repetir. Exemplo de uso:
Filme filme = new Filme(); posso simplesmente colocar: var filmer = new Filme();

construtor: recurso para encapsular objetos
e porque eu nao posso passar tudo como Object no parametro do ArrayList? Pois tudo passa por ele, sem parametro nenhum

foreach: A forma mais comum de percorrer uma lista no Java é utilizando
o laço foreach tradicional, também conhecido como for-each.
Esse laço permite que se percorra todos os elementos de uma lista,
sem a necessidade de se preocupar com índices ou o tamanho dela,
tornando o código mais simples e legível. Por exemplo,
suponha que tenhamos uma lista de nomes de pessoas e que desejamos
imprimi-los na tela:

ArrayList<String> nomes = new ArrayList<>();
nomes.add("Jacqueline");
nomes.add("Paulo");
nomes.add("Suellen");
nomes.add("Emily");

for (String nome : nomes) {
    System.out.println(nome);
}

OU:
nomes.forEach(nome -> System.out.println(nome));

OU:
nomes.forEach(System.out::println);

palavra reservada 'instanceof' é pra verificar se determinado objeto é uma
instância de um objeto

Objeto é quando a gente dá um 'new', variável referência é oq a gente
usa pra chegar até determinado objeto

A classe Collections faz parte do pacote Java Util, e tem o método sort.
Tem muitos utilitários

Na classe Title, eu tive que implementar a classe Comparable pois quero
fazer comparações entre os títulos dos filmes, para os colocar em
ordem alfabética ou ordem de ano de lançamento. Aqui estou dizendo
para comparar alfabeticamente:
  public int compareTo(Title otherTitle) {
        return this.getName().compareTo(otherTitle.getName());
    } pega o nome e compare com o outro nome

Interface List, que é uma sequencia de referencias a objetos. Se usa para
sempre tentar referenciar a um objeto da maneira mais genérica possível
sempre tentar 'conversar' com os objetos através de sua interface
não tem como dar um new numa interface pois ela não tem métodos concretos
que executem alguma coisa

ArrayList
A principal característica do ArrayList é que ele é baseado
em um array dinâmico. Ele armazena os elementos em uma matriz interna e,
conforme novos elementos são adicionados, o tamanho da matriz é
automaticamente ajustado para acomodar o novo elemento.
Da mesma forma, quando um elemento é removido, o tamanho do array
é ajustado para evitar o desperdício de espaço.
O ArrayList é amplamente utilizado devido à sua facilidade de uso
e eficiência em termos de desempenho.

LinkedList
A classe LinkedList fornece uma lista encadeada de elementos.
Diferentemente do ArrayList, que é baseado em um array, o LinkedList
é baseado em uma lista encadeada, o que significa que cada elemento da lista
é um objeto que contém uma referência para o próximo elemento.
Isso permite que os elementos sejam adicionados e removidos de
maneira eficiente em qualquer posição da lista, mas pode tornar
a pesquisa de um elemento específico menos eficiente.

O LinkedList é uma boa escolha quando a inserção e remoção de
elementos em qualquer posição da lista é frequente e quando não
é necessário acessar os elementos de forma aleatória.

Vector
A classe Vector é semelhante ao ArrayList, mas é sincronizada,
o que significa que é segura para uso em threads concorrentes.
No entanto, a sincronização adiciona uma sobrecarga de desempenho,
então o Vector pode ser mais lento que o ArrayList em algumas situações.

Stack
A classe Stack implementa uma pilha, que é uma coleção ordenada
de elementos onde a inserção e remoção de elementos ocorrem sempre
no mesmo extremo da lista. Os elementos são adicionados e removidos
em uma ordem conhecida como "last-in, first-out" (LIFO), ou seja,
o último elemento adicionado é o primeiro a ser removido.
A classe Stack é usada com frequência em algoritmos de processamento
de texto, bem como em outras situações em que a LIFO é a
maneira natural de organizar os dados.

Map
O Map é uma interface que permite que os desenvolvedores associem
chaves a valores. É uma estrutura de dados útil para muitas aplicações
Java, especialmente aquelas que envolvem a manipulação de grandes
quantidades de dados, portanto, é comum usá-lo para realizar buscas,
atualização e recuperação de elementos por chaves

Ele é implementado por diversas classes, sendo a mais comum delas o HashMap.

HashMap
O HashMap é uma classe que implementa a interface Map usando uma
tabela hash para armazenar os pares chave-valor.
Ele é conhecido por sua eficiência em termos de tempo de execução.
Essa classe tem uma complexidade de tempo O(1) - constante - para inserção,
recuperação e remoção de elementos. Isso significa que o desempenho
do HashMap não depende do tamanho da coleção de dados!

No entanto, é importante lembrar que o HashMap não mantém
a ordem de inserção dos elementos e não garante a ordem
dos elementos na saída. Isso ocorre porque a ordem dos elementos
depende da função de hash usada para mapear as chaves para índices
na tabela hash. Além disso, o desempenho do HashMap pode ser afetado
se houver muitas colisões de hash entre as chaves.
----------------------------------------------------------------------
O que é uma API?
ajuda os aplicativos a pedir informações ou a dizer para outro sistema
fazer algo, e depois traz a resposta de volta

Chave da API: é uma chave que vai comunicar para dizer com quem eu
estou "falando" e para "quem" estou devolvendo.

Usando o POSTMAN, irei fazer uma requisição HTTP do tipo GET. Consigo gravar
querys e endereços, pode-se automatizar coisas também.
Lembrando que o apikey que aparece ali no postman, é o MEU código
para acessar (http://www.omdbapi.com/?i=tt3896198&apikey=3b4a3e20)

-Irei utilizar uma biblioteca do Java para fazer as requisições HTTP
usando o link do Java doc, eu consigo localizar essa biblioteca
(https://docs.oracle.com/en/java/javase/17/docs/api/java.net.http/java/net/http/HttpRequest.html)
Irei precisar de um HTTP Client e fazer uma requisição passando um
determinado endereço.

-Primeiro farei o request, usando o seguinte trecho de código:
HttpClient client = HttpClient.newHttpClient();
   HttpRequest request = HttpRequest.newBuilder()
         .uri(URI.create("http://foo.com/"))
         .build();
   o builder aparece muito em outras classes

- Depois de fazer o request, preciso da minha resposta, que é o
HTTP response, novamente precisarei pesquisar no Java Doc.
Com o trecho de código, consigo obter a resposta através do send
que foi enviado no HTTP request do client, obtendo uma String, um JSON representado aqui fazendo o envio pelo client, usando o seguinte trecho de código:
HttpResponse<String> response = client
     .send(request, BodyHandlers.ofString());

-Ao incluir as classes que o compilador pede, ele vai dar um erro no 'send' pois terei de incluir uma excessão, pois alguns tipos de excessões, "alguém" vai ter que tratar, tem algumas exceptions no Java que são obrigadas a serem colocadas, como é o caso dessa.

-Após isso, rodei o programa e consegui fazer a minha busca, pegamos o JSON, o arquivo, que acessa a página na web

**o termo API aparece tanto quando vai consumir uma API (que é o caso do OMDB) chamando um serviço web, quanto para a API das Collections do Java, API HTTP do Java. Para facilitar, quando é código, usar a palavra BIBLIOTECA e quando não consigo enxergar o código como fazer uma requisição na web, eu posso chamar de API**

-Como eu não quero que a aplicação me retorne no formato JSON, irei usar uma biblioteca para manipular a forma como quero ver os dados do filme, para isso, vou usar o site MVN repository para buscar(https://mvnrepository.com/) Blbiotecas, pacotes e APIs. Neste projeto irei utlizar o Gson do Google(estou usando a versão 2.10.1). Para indicar pro projeto que meu projeto depende desse JAR, eu preciso "dizer" isso, ir em File> Project Structure>Dependencies> clicar no botão de + >selecionar o arquivo JAR (ou outro aquivo de outro formato que eu gostaria de utilizar).

-Quando tentei rodar o programa e colocar para que o titulo no filme aparecesse do formato que eu queria, ele retornou como null, pois no JSON o titulo está como "Title", ano de lançamento está como "Year" e não está fechando com o que está no meu código, por isso na classe Title criada por mim, eu tive que usar uma anotação que a gente utiliza como @SerializedName("xxx") onde no parenteses eu coloco a forma como estará escrita no JSON. Mas utilizando desta forma, na minha classe Title, eu posso ter um problema futuramente caso ao invés de "Title" ou "Year" estar escrito de outra forma e ter que ficar fazendo modificações para atender às formas. Para isso, criei um Record que eu irei apenar "traduzir" as formas que vem do JSON para a forma que eu quero.

-Quando rodei, continuou retornando null, mesmo após a criação do Record, isso se deu porque em JSON meu Title e Year etc, começam com letras maiúsculas, e como eu quero seguir as boas práticas, eu vou ver na documentação do Gson o padrão para customizar e nomear minhas variáveis, para que se mantenham minúsculas e seguindo as boas práticas.
Utilizarei então o trecho de código:
Gson gson = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE).create();

-Para indicar a parte exata da informação que eu quero retornar, e precisar "retirar" alguma parte da info, exemplo: pra retornar o meu durationInMinutes eu vou ter que usar o método runtime(), mas vai dar conflito pois já tem uma informação puxada da web que tem o nome como runtime, eu terei que usar o método substring() onde eu passo o que eu quero que retorne, um exemplo é retornar somente os minutos.

-Tratando exceções:
Será bem comum ver o try com mais de um catch, posso tratar exceções diferentes no mesmo bloco do try. Exceções podem ser previstas, tratáveis e antecipadas, um erro não tem como fazer isso

-Quando eu fui fazer a busca do filme Top Gun, que possui um espaço no nome, o compilador me retornou uma exceção, dizendo que como havia um espaço no nome, ele não conseguiria retornar o filme pra mim. Resolvi isso na hora em que eu declarei a variável do endereço (o link do omdb) colocando o método replace(" ","+") onde ele está vendo onde tem um espaço e juntando com a próxima palavra para não dar erro na hora de compilar

-Em relação à exceção do ano no filme Divertidamente que saiu como "2018-" eu criei minha exceção usando o "throw new" na classe Title, e pra isso, eu tive que criar um novo pacote chamado exception e uma classe chamada YearConversionErrorException que herda de RunRimeException. Depois de ter criada a minha exeption, na classe PrincipalWithSearch no bloco try catch, eu consegui colocar a minha mensagem customizada lá.

- Classe FileWriter serve para escrever um arquivo, do pacote Java IO mas quando utilizar?
1.Salvar informações de texto: Logs do sistema, configurações do usuário, dados que seu programa gerou, etc.

2.Exportar dados: Gerar um arquivo .txt com resultados de processamento.

3.Criar ou sobrescrever arquivos: Se o arquivo não existir, o FileWriter o cria. Se existir, ele pode sobrescrever o conteúdo (por padrão) ou anexar novos dados.
Criei um FileWriter dentro do meu principal para conseguir pegar os dados e colocar num arquivo .txt

-As classes FileReader e FileWriter são usadas para ler e escrever dados em arquivos de texto, sendo que a classe FileReader lê os caracteres de um arquivo de texto, enquanto a classe FileWriter escreve os caracteres.

-BufferedReader e BufferedWriter: são usadas para ler e gravar arquivos de texto de maneira eficiente, lendo e escrevendo uma linha por vez. Elas usam um buffer para armazenar os dados, o que torna a leitura e escrita mais rápida do que quando feita um caractere por vez;

-FileInputStream e FileOutputStream: são usadas para ler e gravar dados binários em um arquivo. Eles são usados para ler e gravar dados em arquivos que não são de texto, como imagens e arquivos de áudio;

-ObjectInputStream e ObjectOutputStream: são usadas para ler e gravar objetos em arquivos. Isso permite que você armazene objetos Java em arquivos para uso posterior ou para transferência entre diferentes aplicações.

- Criei também uma List de Title para que eu consiga adicionar esses filmes numa lista para gravá-los no meu .txt

-No meu FileWriter eu coloquei a minha lista de titulos para ele tranformar em json

-Método setPrettyPrinting() arruma o arquivo em JSON para ficar de uma forma mais bonita de se ler

-o Record é um recurso que permite representar uma classe imutável, contendo apenas atributos, construtor e métodos de leitura, de uma maneira muito simples e enxuta.

 Esse recurso se encaixa perfeitamente quando precisamos criar um objeto apenas para representar dados, sem nenhum tipo de comportamento.
-------------------------------------------------
- Qual a diferença entre Biblioteca, API e Frameworks?
-Biblioteca: digamos que eu quero pregar algo na parede, eu pego um martelo, ele será minha "biblioteca", ou seja, minha ferramenta para executar isso. Biblioteca não afeta diretamente na minha aplicação, pois eu defino quando ela fará determinada coisa.
JQuery é uma biblioteca bem conhecida, exemplo de uso é no acesso de sites

-Framework: afeta diretamente como escrevo e desenvolvo minha aplicação,preciso me encaixar nele. Exemplo: se pegar os carros Gol, Voyage e  Saveiro, eles são parecidos porque foram utilizadas as mesmas estruturas para construí-los. O Framowork é a mesma coisa, ele define a estrutura básica que preciso ter durante a construção da aplicação
React, unindo com outras soluções, ele se tranforma um framework, pois define a forma como a aplicação será feita, ele quem decide quando as coisas vão acontecer.

-API: é a forma como eu interajo com alguma coisa dentro do sistema. Exemplo: estou usando o YT, o YT faz uma chamada pra API de video para descobrir onde está o arquivo deste vídeo, chamando assim outra API que é a do navegador que diz "pega este video que está neste pedaço da tela e bota o vídeo pra tocar".

-------------------------------------------------------
-Springboot:
